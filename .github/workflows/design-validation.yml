name: Design Assets Validation

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'docs/**'
      - 'templates/**'
      - 'assets/**'
      - 'roadmap/**'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'docs/**'
      - 'templates/**'
      - 'assets/**'
      - 'roadmap/**'
  workflow_dispatch:

jobs:
  validate-design-structure:
    name: Validate Design Structure
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Validate directory structure
      shell: bash
      run: |
        echo "Validating design repository structure..."
        
        # Detect available Python command
        python_cmd="python3"
        if ! command -v python3 >/dev/null 2>&1; then
          if command -v python >/dev/null 2>&1; then
            python_cmd="python"
          else
            echo "Error: Python not found"
            exit 1
          fi
        fi
        
        # Use Python for cross-platform directory validation
        $python_cmd << 'EOF'
import os
import glob

# Check required directories exist
required_dirs = ['docs', 'templates', 'assets', 'roadmap']
for dir_name in required_dirs:
    if not os.path.exists(dir_name):
        print(f'Warning: Required directory \'{dir_name}\' not found')
    else:
        print(f'✓ Found directory: {dir_name}')

# Check for core documentation files
print('Checking for core documentation files...')
if os.path.exists('docs/README.md'):
    print('✓ Found docs/README.md')
else:
    print('Warning: docs/README.md not found')

# Validate template files
if os.path.exists('templates'):
    print('Checking template files...')
    template_count = len(glob.glob('templates/**/*.md', recursive=True))
    print(f'Found {template_count} template files')
else:
    print('Warning: templates directory not found')
EOF
        
        echo "Design structure validation completed"
        
    - name: Check for broken links in documentation
      shell: bash
      run: |
        echo "Checking for broken internal links..."
        
        # Detect available Python command
        python_cmd="python3"
        if ! command -v python3 >/dev/null 2>&1; then
          if command -v python >/dev/null 2>&1; then
            python_cmd="python"
          else
            echo "Error: Python not found"
            exit 1
          fi
        fi
        
        # Cross-platform link checking using Python for better compatibility
        $python_cmd << 'EOF'
import os
import re
import glob

def check_links_in_docs():
    link_pattern = re.compile(r'\[.*?\]\(([^)]*\.md)\)')
    
    md_files = glob.glob('docs/**/*.md', recursive=True)
    md_files.extend(glob.glob('*.md'))  # Include root level md files
    
    for md_file in md_files:
        if os.path.isfile(md_file):
            print(f'Checking links in: {md_file}')
            try:
                with open(md_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    
                for match in link_pattern.finditer(content):
                    link = match.group(1)
                    if not link.startswith('http'):
                        # Convert relative path to absolute path
                        if link.startswith('./'):
                            link = link[2:]
                        
                        # Calculate the target file path
                        base_dir = os.path.dirname(md_file)
                        target_path = os.path.normpath(os.path.join(base_dir, link))
                        
                        if not os.path.exists(target_path):
                            print(f'Warning: Potentially broken link in {md_file}: {link}')
            except Exception as e:
                print(f'Error reading {md_file}: {e}')

check_links_in_docs()
EOF
        
        echo "Link validation completed"
        
    - name: Validate file naming conventions
      shell: bash
      run: |
        echo "Checking file naming conventions..."
        
        # Detect available Python command
        python_cmd="python3"
        if ! command -v python3 >/dev/null 2>&1; then
          if command -v python >/dev/null 2>&1; then
            python_cmd="python"
          else
            echo "Error: Python not found"
            exit 1
          fi
        fi
        
        # Use Python for cross-platform file name validation
        $python_cmd << 'EOF'
import os
import glob

def check_naming_conventions():
    # Check for files with spaces in names (should use hyphens)
    files_with_spaces = []
    for root, dirs, files in os.walk('.'):
        # Skip .git directory
        if '.git' in root:
            continue
        for file in files:
            if ' ' in file:
                files_with_spaces.append(os.path.join(root, file))
    
    for file in files_with_spaces:
        print(f'Warning: File with spaces in name: {file}')
    
    # Check for uppercase in markdown files (should be lowercase)
    md_files_with_uppercase = []
    patterns = ['docs/**/*.md', 'templates/**/*.md', '*.md']
    for pattern in patterns:
        for file in glob.glob(pattern, recursive=True):
            basename = os.path.basename(file)
            if any(c.isupper() for c in basename):
                md_files_with_uppercase.append(file)
    
    for file in md_files_with_uppercase:
        print(f'Info: Consider using lowercase for consistency: {file}')
    
    if not files_with_spaces and not md_files_with_uppercase:
        print('✓ File naming conventions look good')

check_naming_conventions()
EOF
        
        echo "File naming validation completed"