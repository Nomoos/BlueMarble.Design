# Anti-Exploitation and Protection Systems

**Version:** 1.0  
**Date:** 2025-01-06  
**Status:** Design Specification

## Overview

The Anti-Exploitation and Protection System (Ochrana proti exploitaci) provides comprehensive multi-layered defense mechanisms to prevent griefing, resource theft, and unfair exploitation in the BlueMarble world. This system emphasizes player agency, community enforcement, and balanced deterrence while maintaining gameplay freedom.

## Core Design Philosophy

### Multi-Layered Protection

Defense through overlapping systems:
- Property rights and ownership claims
- Permission-based access control
- Community enforcement mechanisms
- Personal patrol and active defense
- Automated detection and prevention
- Administrative oversight

### Player Agency

Players control their own protection:
- Customizable security measures
- Personal physical patrol options
- Alliances and protection pacts
- Insurance and recovery systems
- Conflict resolution choices

### Balanced Deterrence

Consequences that discourage griefing without eliminating conflict:
- Proportional punishment for violations
- Reputation systems affect gameplay
- Criminal tags impact interactions
- Recovery mechanisms for victims
- Legitimate conflict remains viable

## System Components

### 1. Property Rights System

#### Land Ownership

```csharp
public class LandClaim
{
    public string ClaimId { get; set; }
    public Player Owner { get; set; }
    public Polygon Boundary { get; set; }
    public float Area { get; set; }  // Square meters
    public DateTime ClaimedAt { get; set; }
    public LandUse PermittedUse { get; set; }
    public ProtectionLevel Protection { get; set; }
    
    public static LandClaim CreateClaim(
        Player owner,
        Polygon boundary,
        GeologicalData geology)
    {
        // Validate claim size
        float area = boundary.AreaSquareMeters;
        if (area > owner.GetMaxClaimArea())
            throw new InvalidOperationException("Exceeds maximum claim size");
            
        // Check for overlapping claims
        if (HasOverlappingClaims(boundary))
            throw new InvalidOperationException("Overlaps existing claim");
            
        // Verify player can afford claim
        float claimCost = CalculateClaimCost(area, geology);
        if (owner.Currency < claimCost)
            throw new InvalidOperationException("Insufficient funds");
            
        // Deduct cost
        owner.Currency -= claimCost;
        
        return new LandClaim
        {
            ClaimId = GenerateClaimId(),
            Owner = owner,
            Boundary = boundary,
            Area = area,
            ClaimedAt = DateTime.UtcNow,
            Protection = ProtectionLevel.Private
        };
    }
    
    public bool CanAccess(Player player, AccessType access)
    {
        // Owner always has full access
        if (player == Owner)
            return true;
            
        // Check permission list
        var permission = GetPermission(player);
        if (permission == null)
            return Protection == ProtectionLevel.Public;
            
        return permission.AllowsAccess(access);
    }
}

public enum ProtectionLevel
{
    Public,       // Anyone can access
    Protected,    // Explicit permissions required for modifications
    Private,      // No access except owner and permitted
    Locked        // Absolute no access except owner
}

public enum AccessType
{
    Enter,        // Walk through
    View,         // See contents
    Extract,      // Mine resources
    Build,        // Construct buildings
    Modify,       // Terraform or alter
    Destroy,      // Damage or remove
    Administrate  // Manage permissions
}
```

#### Permission Management

```csharp
public class PermissionSystem
{
    public LandClaim Claim { get; set; }
    public Dictionary<Player, Permission> PlayerPermissions { get; set; }
    public Dictionary<Guild, Permission> GuildPermissions { get; set; }
    
    public void GrantPermission(
        Player player,
        AccessType[] allowedAccess,
        DateTime? expiresAt = null)
    {
        var permission = new Permission
        {
            Grantee = player,
            AllowedAccess = allowedAccess.ToList(),
            GrantedAt = DateTime.UtcNow,
            ExpiresAt = expiresAt
        };
        
        PlayerPermissions[player] = permission;
        
        // Log permission grant
        LogPermissionChange(player, permission, "granted");
    }
    
    public void RevokePermission(Player player)
    {
        if (PlayerPermissions.ContainsKey(player))
        {
            PlayerPermissions.Remove(player);
            LogPermissionChange(player, null, "revoked");
        }
    }
    
    public Permission GetPermission(Player player)
    {
        // Check direct player permission
        if (PlayerPermissions.TryGetValue(player, out var permission))
        {
            if (!permission.IsExpired())
                return permission;
        }
        
        // Check guild permissions
        if (player.Guild != null && 
            GuildPermissions.TryGetValue(player.Guild, out var guildPermission))
        {
            if (!guildPermission.IsExpired())
                return guildPermission;
        }
        
        return null;
    }
}

public class Permission
{
    public Player Grantee { get; set; }
    public List<AccessType> AllowedAccess { get; set; }
    public DateTime GrantedAt { get; set; }
    public DateTime? ExpiresAt { get; set; }
    
    public bool AllowsAccess(AccessType access)
    {
        return !IsExpired() && AllowedAccess.Contains(access);
    }
    
    public bool IsExpired()
    {
        return ExpiresAt.HasValue && DateTime.UtcNow > ExpiresAt.Value;
    }
}
```

### 2. Resource Protection

#### Protected Containers

```csharp
public class ProtectedContainer
{
    public string ContainerId { get; set; }
    public Player Owner { get; set; }
    public Inventory Contents { get; set; }
    public LockType Lock { get; set; }
    public List<Player> AuthorizedUsers { get; set; }
    
    public bool CanAccess(Player player)
    {
        // Owner always has access
        if (player == Owner)
            return true;
            
        // Check authorization list
        if (AuthorizedUsers.Contains(player))
            return true;
            
        // Check if player can pick lock
        if (Lock != LockType.None)
        {
            return CanPickLock(player, Lock);
        }
        
        return Lock == LockType.None;
    }
    
    private bool CanPickLock(Player player, LockType lockType)
    {
        // Lockpicking is a skill, but marks player as criminal
        if (player.Skills.Lockpicking >= GetLockDifficulty(lockType))
        {
            // Successful lockpick attempt marks as theft
            player.AddCriminalTag(CrimeType.Theft, DateTime.UtcNow);
            
            // Alert owner and nearby players
            AlertOwnerOfBreachAttempt(player);
            
            return true;
        }
        
        return false;
    }
}

public enum LockType
{
    None,
    Basic,
    Standard,
    Advanced,
    Masterwork,
    Magical
}
```

#### Mining Claims

```csharp
public class MiningClaim
{
    public string ClaimId { get; set; }
    public Player Owner { get; set; }
    public Coordinate3D Location { get; set; }
    public float Radius { get; set; }  // Claimed area radius
    public MineralType ClaimedMineral { get; set; }
    public DateTime ClaimedAt { get; set; }
    public DateTime ExpiresAt { get; set; }
    
    public static MiningClaim FileClaim(
        Player owner,
        Coordinate3D location,
        float radius,
        MineralType mineral)
    {
        // Validate claim
        if (HasOverlappingMiningClaim(location, radius))
            throw new InvalidOperationException("Overlaps existing mining claim");
            
        // Verify mineral deposit exists
        var geology = GetGeology(location);
        if (!geology.HasMineral(mineral, location, radius))
            throw new InvalidOperationException("No significant deposit found");
            
        // Calculate claim cost and duration
        float cost = CalculateMiningClaimCost(radius, mineral);
        var duration = TimeSpan.FromDays(365);  // 1 year default
        
        if (owner.Currency < cost)
            throw new InvalidOperationException("Insufficient funds");
            
        owner.Currency -= cost;
        
        return new MiningClaim
        {
            ClaimId = GenerateClaimId(),
            Owner = owner,
            Location = location,
            Radius = radius,
            ClaimedMineral = mineral,
            ClaimedAt = DateTime.UtcNow,
            ExpiresAt = DateTime.UtcNow + duration
        };
    }
    
    public bool IsViolatedBy(Player player, Coordinate3D extractionLocation)
    {
        // Owner can always extract
        if (player == Owner)
            return false;
            
        // Check if extraction is within claim
        float distance = CalculateDistance(Location, extractionLocation);
        if (distance > Radius)
            return false;
            
        // Claim is violated
        return true;
    }
}
```

### 3. Active Defense Systems

#### Personal Patrol

```csharp
public class PersonalPatrol
{
    public Player Patroller { get; set; }
    public LandClaim PatrolArea { get; set; }
    public PatrolRoute Route { get; set; }
    public bool Active { get; set; }
    
    public void MonitorArea(float deltaTime)
    {
        if (!Active)
            return;
            
        // Detect trespassers
        var trespassers = DetectUnauthorizedPlayers(PatrolArea);
        
        foreach (var trespasser in trespassers)
        {
            // Alert owner
            AlertOwner(trespasser);
            
            // Optionally engage
            if (Patroller.PatrolPolicy == PatrolPolicy.Aggressive)
            {
                EngageTrespasser(trespasser);
            }
            else
            {
                WarnTrespasser(trespasser);
            }
        }
        
        // Check for property damage
        var damageEvents = DetectPropertyDamage(PatrolArea, deltaTime);
        foreach (var damage in damageEvents)
        {
            HandlePropertyDamage(damage);
        }
    }
    
    private void EngageTrespasser(Player trespasser)
    {
        // Physical confrontation
        if (trespasser.HasViolatedProperty(PatrolArea))
        {
            // Owner can engage in combat without criminal tag
            InitiateCombat(Patroller, trespasser, combatReason: "property_defense");
        }
    }
}

public enum PatrolPolicy
{
    Passive,      // Only observe and alert
    Warning,      // Issue warnings before action
    Defensive,    // Engage if threatened
    Aggressive    // Immediately engage trespassers
}
```

#### Defensive Structures

```csharp
public class DefensiveStructure
{
    public string StructureId { get; set; }
    public StructureType Type { get; set; }
    public Coordinate3D Location { get; set; }
    public Player Owner { get; set; }
    public float Integrity { get; set; }  // 0.0 - 1.0
    public bool Active { get; set; }
    
    public void MonitorAndRespond(float deltaTime)
    {
        if (!Active || Integrity <= 0)
            return;
            
        var threats = DetectThreats();
        
        foreach (var threat in threats)
        {
            if (ShouldEngage(threat))
            {
                Engage(threat);
            }
        }
        
        // Degrade over time
        Integrity -= CalculateDegradation(deltaTime);
    }
    
    private List<Threat> DetectThreats()
    {
        var threats = new List<Threat>();
        
        // Detect unauthorized players
        var nearbyPlayers = GetNearbyPlayers(Location, DetectionRange);
        foreach (var player in nearbyPlayers)
        {
            var claim = GetLandClaim(Location);
            if (claim != null && !claim.CanAccess(player, AccessType.Enter))
            {
                threats.Add(new Threat
                {
                    Type = ThreatType.Trespasser,
                    Source = player,
                    Severity = ThreatSeverity.Low
                });
            }
        }
        
        return threats;
    }
}

public enum StructureType
{
    Watchtower,       // Detection and alerting
    Palisade,         // Physical barrier
    Gate,             // Controlled access point
    TrapSystem,       // Passive deterrent
    Alarm,            // Alert system
    AutoTurret        // Active defense (advanced)
}
```

### 4. Criminal System

#### Crime Tracking

```csharp
public class CriminalRecord
{
    public Player Player { get; set; }
    public List<CrimeEntry> Crimes { get; set; }
    public float ReputationScore { get; set; }  // -100 to 100
    public CriminalStatus Status { get; set; }
    
    public void RecordCrime(
        CrimeType crime,
        Player victim,
        Coordinate3D location,
        float severity)
    {
        var entry = new CrimeEntry
        {
            Crime = crime,
            Victim = victim,
            Location = location,
            Severity = severity,
            Timestamp = DateTime.UtcNow,
            Witnessed = GetWitnesses(location)
        };
        
        Crimes.Add(entry);
        
        // Update reputation
        ReputationScore -= severity * 10;
        
        // Update criminal status
        UpdateCriminalStatus();
        
        // Alert authorities and victim
        AlertAuthorities(entry);
        AlertVictim(victim, entry);
    }
    
    private void UpdateCriminalStatus()
    {
        // Calculate recent crime score
        var recentCrimes = Crimes
            .Where(c => c.Timestamp > DateTime.UtcNow.AddDays(-30))
            .Sum(c => c.Severity);
            
        if (recentCrimes > 50)
        {
            Status = CriminalStatus.Outlaw;
        }
        else if (recentCrimes > 20)
        {
            Status = CriminalStatus.Criminal;
        }
        else if (recentCrimes > 5)
        {
            Status = CriminalStatus.Suspicious;
        }
        else
        {
            Status = CriminalStatus.Clean;
        }
    }
}

public class CrimeEntry
{
    public CrimeType Crime { get; set; }
    public Player Victim { get; set; }
    public Coordinate3D Location { get; set; }
    public float Severity { get; set; }  // 0-10 scale
    public DateTime Timestamp { get; set; }
    public List<Player> Witnessed { get; set; }
}

public enum CrimeType
{
    Theft,              // Stealing items
    Trespassing,        // Entering private property
    PropertyDamage,     // Destroying buildings/structures
    ResourceTheft,      // Mining on others' claims
    Assault,            // Unprovoked combat
    Murder,             // Killing another player
    Griefing           // Intentional harassment
}

public enum CriminalStatus
{
    Clean,             // No recent crimes
    Suspicious,        // Minor infractions
    Criminal,          // Serious crimes
    Outlaw            // Major criminal, KOS (Kill on Sight)
}
```

#### Bounty System

```csharp
public class BountySystem
{
    public Dictionary<Player, List<Bounty>> ActiveBounties { get; set; }
    
    public Bounty PlaceBounty(
        Player issuer,
        Player target,
        float reward,
        BountyCondition condition)
    {
        // Validate bounty
        if (issuer.Currency < reward)
            throw new InvalidOperationException("Insufficient funds");
            
        // Escrow reward
        issuer.Currency -= reward;
        
        var bounty = new Bounty
        {
            BountyId = GenerateBountyId(),
            Issuer = issuer,
            Target = target,
            Reward = reward,
            Condition = condition,
            Status = BountyStatus.Active,
            IssuedAt = DateTime.UtcNow
        };
        
        if (!ActiveBounties.ContainsKey(target))
            ActiveBounties[target] = new List<Bounty>();
            
        ActiveBounties[target].Add(bounty);
        
        return bounty;
    }
    
    public void ClaimBounty(Bounty bounty, Player hunter, Evidence evidence)
    {
        // Verify evidence
        if (!ValidateEvidence(bounty, evidence))
            throw new InvalidOperationException("Invalid evidence");
            
        // Pay reward
        hunter.Currency += bounty.Reward;
        
        // Update bounty status
        bounty.Status = BountyStatus.Claimed;
        bounty.ClaimedBy = hunter;
        bounty.ClaimedAt = DateTime.UtcNow;
        
        // Remove from active list
        ActiveBounties[bounty.Target].Remove(bounty);
        
        // Log bounty claim
        LogBountyCompletion(bounty, hunter);
    }
}

public class Bounty
{
    public string BountyId { get; set; }
    public Player Issuer { get; set; }
    public Player Target { get; set; }
    public float Reward { get; set; }
    public BountyCondition Condition { get; set; }
    public BountyStatus Status { get; set; }
    public DateTime IssuedAt { get; set; }
    public Player ClaimedBy { get; set; }
    public DateTime? ClaimedAt { get; set; }
}

public enum BountyCondition
{
    Kill,              // Kill the target
    Capture,           // Bring target to location
    Evidence,          // Provide evidence of crime
    Banishment         // Drive from region
}
```

### 5. Community Enforcement

#### Guild Protection

```csharp
public class GuildProtection
{
    public Guild Guild { get; set; }
    public List<LandClaim> ProtectedTerritory { get; set; }
    public List<Player> ProtectedMembers { get; set; }
    
    public void RespondToViolation(ViolationEvent violation)
    {
        // Alert guild members
        AlertGuildMembers(violation);
        
        // Automatic response based on guild policy
        switch (Guild.ProtectionPolicy)
        {
            case ProtectionPolicy.Passive:
                LogViolation(violation);
                break;
                
            case ProtectionPolicy.Active:
                DispatchGuildGuards(violation.Location);
                break;
                
            case ProtectionPolicy.Aggressive:
                InitiateGuildRetaliation(violation.Offender);
                break;
        }
        
        // Consider adding offender to guild enemy list
        if (violation.Severity >= ViolationSeverity.High)
        {
            Guild.AddEnemy(violation.Offender);
        }
    }
}

public enum ProtectionPolicy
{
    Passive,       // Record only
    Active,        // Respond to violations
    Aggressive     // Proactive defense
}
```

#### Alliance Systems

```csharp
public class Alliance
{
    public string AllianceId { get; set; }
    public List<Guild> Members { get; set; }
    public DefensePact Pact { get; set; }
    
    public void TriggerMutualDefense(Guild attackedMember, Player aggressor)
    {
        if (!Pact.IncludesMutualDefense)
            return;
            
        // Alert all alliance members
        foreach (var guild in Members)
        {
            if (guild != attackedMember)
            {
                guild.AlertToAllyAttack(attackedMember, aggressor);
                
                // Optionally dispatch aid
                if (guild.WillAidAlly(attackedMember, Pact))
                {
                    guild.DispatchAid(attackedMember.Territory);
                }
            }
        }
    }
}
```

### 6. Automated Protection

#### Intrusion Detection

```csharp
public class IntrusionDetection
{
    public void MonitorArea(LandClaim claim, float deltaTime)
    {
        // Get all entities in claim area
        var entities = GetEntitiesInArea(claim.Boundary);
        
        foreach (var entity in entities)
        {
            if (entity is Player player)
            {
                // Check authorization
                if (!claim.CanAccess(player, AccessType.Enter))
                {
                    HandleIntrusion(claim, player);
                }
            }
        }
    }
    
    private void HandleIntrusion(LandClaim claim, Player intruder)
    {
        // Log intrusion
        LogIntrusion(claim, intruder, DateTime.UtcNow);
        
        // Alert owner
        AlertOwner(claim.Owner, intruder);
        
        // Apply automatic consequences based on settings
        if (claim.AutoEject)
        {
            EjectPlayer(intruder, claim.Boundary);
        }
        
        // Add trespassing to criminal record
        intruder.CriminalRecord.RecordCrime(
            CrimeType.Trespassing,
            claim.Owner,
            intruder.Location,
            severity: 2.0f
        );
    }
}
```

#### Anti-Exploit Detection

```csharp
public class AntiExploitSystem
{
    public void MonitorPlayerActions(Player player, GameAction action)
    {
        // Check for suspicious patterns
        if (IsExploitPattern(player, action))
        {
            HandleSuspiciousActivity(player, action);
        }
        
        // Rate limiting
        if (ExceedsRateLimit(player, action))
        {
            ThrottleAction(player, action);
        }
        
        // Resource duplication detection
        if (IsDuplicationAttempt(player, action))
        {
            BlockAction(player, action);
            AlertAdministrators(player, "duplication_attempt");
        }
    }
    
    private bool IsExploitPattern(Player player, GameAction action)
    {
        // Check for known exploit patterns
        var recentActions = GetRecentActions(player, TimeSpan.FromMinutes(5));
        
        // Rapid resource collection
        if (action.Type == ActionType.ResourceExtraction)
        {
            int extractionCount = recentActions
                .Count(a => a.Type == ActionType.ResourceExtraction);
                
            if (extractionCount > 100)  // 100 extractions in 5 minutes
                return true;
        }
        
        // Impossible movement speed
        if (action.Type == ActionType.Movement)
        {
            float distance = CalculateDistance(
                player.PreviousLocation,
                player.Location
            );
            float timeDelta = action.Timestamp - player.LastActionTime;
            float speed = distance / timeDelta;
            
            if (speed > MaxNormalSpeed * 2)  // 2x normal speed
                return true;
        }
        
        return false;
    }
}
```

### 7. Recovery and Insurance

#### Insurance System

```csharp
public class PropertyInsurance
{
    public string PolicyId { get; set; }
    public Player Policyholder { get; set; }
    public List<InsuredItem> InsuredItems { get; set; }
    public float Premium { get; set; }
    public float Coverage { get; set; }
    public DateTime ExpiresAt { get; set; }
    
    public Claim FileClaim(
        InsuredItem item,
        LossType lossType,
        Evidence evidence)
    {
        // Verify item is insured
        if (!InsuredItems.Contains(item))
            throw new InvalidOperationException("Item not insured");
            
        // Verify policy is active
        if (DateTime.UtcNow > ExpiresAt)
            throw new InvalidOperationException("Policy expired");
            
        // Create claim
        var claim = new Claim
        {
            ClaimId = GenerateClaimId(),
            Policy = this,
            Item = item,
            LossType = lossType,
            Evidence = evidence,
            FiledAt = DateTime.UtcNow,
            Status = ClaimStatus.UnderReview
        };
        
        // Process claim
        ProcessClaim(claim);
        
        return claim;
    }
    
    private void ProcessClaim(Claim claim)
    {
        // Validate evidence
        if (!ValidateEvidence(claim.Evidence))
        {
            claim.Status = ClaimStatus.Denied;
            return;
        }
        
        // Calculate payout
        float payout = CalculatePayout(claim);
        
        // Pay claim
        claim.Policyholder.Currency += payout;
        claim.Status = ClaimStatus.Paid;
        claim.PaidAmount = payout;
    }
}
```

#### Recovery Mechanisms

```csharp
public class RecoverySystem
{
    public void InitiateRecovery(Player victim, LossEvent loss)
    {
        // Log the loss
        LogLoss(victim, loss);
        
        // Attempt automatic recovery
        if (CanAutoRecover(loss))
        {
            AutoRecover(victim, loss);
            return;
        }
        
        // Community assistance
        if (victim.Guild != null)
        {
            victim.Guild.OfferAssistance(victim, loss);
        }
        
        // Insurance claim
        if (HasInsurance(victim, loss))
        {
            ProcessInsuranceClaim(victim, loss);
        }
        
        // Justice system
        if (loss.Perpetrator != null)
        {
            InitiateJusticeProcess(victim, loss.Perpetrator, loss);
        }
    }
    
    private bool CanAutoRecover(LossEvent loss)
    {
        // Recent losses can be rolled back
        return loss.Timestamp > DateTime.UtcNow.AddMinutes(-5) &&
               loss.Type == LossType.Theft &&
               loss.Perpetrator != null;
    }
}
```

## Testing Requirements

### Unit Tests

1. **Permission Validation**: Verify access control logic
2. **Crime Detection**: Test violation detection
3. **Bounty System**: Validate bounty mechanics
4. **Insurance Claims**: Test claim processing

### Integration Tests

1. **Property Defense**: Complete defense scenario
2. **Criminal Tracking**: Crime through punishment
3. **Guild Protection**: Multi-player coordination
4. **Recovery Process**: Loss to recovery workflow

### Security Tests

1. **Exploit Attempts**: Test anti-exploit detection
2. **Permission Bypass**: Attempt unauthorized access
3. **Duplication Detection**: Test item duplication prevention
4. **Rate Limiting**: Verify throttling mechanisms

## Related Documentation

- [Mining and Resource Extraction](./mining-resource-extraction.md)
- [Building and Construction](./building-construction.md)
- [Terraforming Systems](./terraforming.md)
- [Trade Systems](./trade-system.md)
- [Security Framework](../../systems/security-framework-design.md)
- [Game Mechanics Design](../../GAME_MECHANICS_DESIGN.md)

## Implementation Notes

### Security Considerations

- All property checks server-side
- Encrypted communication for sensitive operations
- Audit logging for all violations
- Rate limiting on all player actions
- Automated detection of suspicious patterns

### Performance Considerations

- Spatial indexing for property boundaries
- Efficient permission lookup caching
- Optimized intrusion detection
- Batched alert processing

### Player Experience

- Clear visual indicators of property boundaries
- Intuitive permission management interface
- Real-time alerts for violations
- Transparent criminal system with appeals
